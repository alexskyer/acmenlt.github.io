<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前言 | 龙台技术笔记</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/images/book.png">
    <link rel="manifest" href="/images/book.png">
    <link rel="apple-touch-icon" href="/images/book.png">
    <meta name="description" content="技术人写的技术笔记（工作总结）">
    <meta http-quiv="pragma" cotent="no-cache">
    <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
    <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.56f8f03c.css" as="style"><link rel="preload" href="/assets/js/app.9f6db045.js" as="script"><link rel="preload" href="/assets/js/2.ad010850.js" as="script"><link rel="preload" href="/assets/js/41.d75e30b9.js" as="script"><link rel="prefetch" href="/assets/js/10.cbffc92a.js"><link rel="prefetch" href="/assets/js/11.05ca654e.js"><link rel="prefetch" href="/assets/js/12.ad56d1ad.js"><link rel="prefetch" href="/assets/js/13.cbb68b5f.js"><link rel="prefetch" href="/assets/js/14.deb3efeb.js"><link rel="prefetch" href="/assets/js/15.4bd8d806.js"><link rel="prefetch" href="/assets/js/16.18544ac8.js"><link rel="prefetch" href="/assets/js/17.3d970734.js"><link rel="prefetch" href="/assets/js/18.24bdf351.js"><link rel="prefetch" href="/assets/js/19.20ee8468.js"><link rel="prefetch" href="/assets/js/20.76cc2f2f.js"><link rel="prefetch" href="/assets/js/21.a060d59a.js"><link rel="prefetch" href="/assets/js/22.8dd2c3cb.js"><link rel="prefetch" href="/assets/js/23.38503d1a.js"><link rel="prefetch" href="/assets/js/24.b5bab63e.js"><link rel="prefetch" href="/assets/js/25.f541c5de.js"><link rel="prefetch" href="/assets/js/26.ee0820ec.js"><link rel="prefetch" href="/assets/js/27.8e2f5fd3.js"><link rel="prefetch" href="/assets/js/28.b05c6b48.js"><link rel="prefetch" href="/assets/js/29.19cdc57c.js"><link rel="prefetch" href="/assets/js/3.d533eea8.js"><link rel="prefetch" href="/assets/js/30.98878ec6.js"><link rel="prefetch" href="/assets/js/31.572b5ab4.js"><link rel="prefetch" href="/assets/js/32.bce65027.js"><link rel="prefetch" href="/assets/js/33.37e89393.js"><link rel="prefetch" href="/assets/js/34.ba1a6fba.js"><link rel="prefetch" href="/assets/js/35.c7dd14b8.js"><link rel="prefetch" href="/assets/js/36.91b56d4a.js"><link rel="prefetch" href="/assets/js/37.818f9351.js"><link rel="prefetch" href="/assets/js/38.f7f3e6b0.js"><link rel="prefetch" href="/assets/js/39.4a1489dc.js"><link rel="prefetch" href="/assets/js/4.d52d5841.js"><link rel="prefetch" href="/assets/js/40.175dfc07.js"><link rel="prefetch" href="/assets/js/42.dcfe80e6.js"><link rel="prefetch" href="/assets/js/43.4669e03d.js"><link rel="prefetch" href="/assets/js/44.5b6aa46b.js"><link rel="prefetch" href="/assets/js/5.8c9ed1e9.js"><link rel="prefetch" href="/assets/js/6.256d2fbb.js"><link rel="prefetch" href="/assets/js/7.26cc56f0.js"><link rel="prefetch" href="/assets/js/8.d0a0d91a.js"><link rel="prefetch" href="/assets/js/9.272d66c4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.56f8f03c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">龙台技术笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/db/" class="nav-link">
  数据库
</a></div><div class="nav-item"><a href="/thread/" class="nav-link router-link-active">
  并发编程
</a></div><div class="nav-item"><a href="/frame/" class="nav-link">
  框架知识
</a></div><div class="nav-item"><a href="/design/" class="nav-link">
  代码设计
</a></div><div class="nav-item"><a href="/bug/" class="nav-link">
  BUG 专栏
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其它" class="dropdown-title"><span class="title">其它</span> <span class="arrow down"></span></button> <button type="button" aria-label="其它" class="mobile-dropdown-title"><span class="title">其它</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/acmenlt" target="_blank" rel="noopener noreferrer" class="nav-link external">
  动态线程池
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/acmenlt/House-Notes" target="_blank" rel="noopener noreferrer" class="nav-link external">
  买房实践
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="https://github.com/acmenlt" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/db/" class="nav-link">
  数据库
</a></div><div class="nav-item"><a href="/thread/" class="nav-link router-link-active">
  并发编程
</a></div><div class="nav-item"><a href="/frame/" class="nav-link">
  框架知识
</a></div><div class="nav-item"><a href="/design/" class="nav-link">
  代码设计
</a></div><div class="nav-item"><a href="/bug/" class="nav-link">
  BUG 专栏
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其它" class="dropdown-title"><span class="title">其它</span> <span class="arrow down"></span></button> <button type="button" aria-label="其它" class="mobile-dropdown-title"><span class="title">其它</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/acmenlt" target="_blank" rel="noopener noreferrer" class="nav-link external">
  动态线程池
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/acmenlt/House-Notes" target="_blank" rel="noopener noreferrer" class="nav-link external">
  买房实践
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="https://github.com/acmenlt" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前言</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#前言" class="sidebar-link">前言</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#什么是-reentrantlock" class="sidebar-link">什么是 ReentrantLock</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#什么是-aqs" class="sidebar-link">什么是 AQS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#aqs-核心原理" class="sidebar-link">AQS 核心原理</a></li><li class="sidebar-sub-header"><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#clh-队列" class="sidebar-link">CLH 队列</a></li><li class="sidebar-sub-header"><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#认识-aos" class="sidebar-link">认识 AOS</a></li><li class="sidebar-sub-header"><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#为什么要掌握-aqs" class="sidebar-link">为什么要掌握 AQS</a></li></ul></li><li><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#独占加锁源码解析" class="sidebar-link">独占加锁源码解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#什么是独占锁" class="sidebar-link">什么是独占锁</a></li><li class="sidebar-sub-header"><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#独占锁加锁" class="sidebar-link">独占锁加锁</a></li><li class="sidebar-sub-header"><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#node-入队流程" class="sidebar-link">Node 入队流程</a></li><li class="sidebar-sub-header"><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#cancelacquire" class="sidebar-link">cancelAcquire</a></li></ul></li><li><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#独占解锁源码解析" class="sidebar-link">独占解锁源码解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#释放锁同步状态" class="sidebar-link">释放锁同步状态</a></li><li class="sidebar-sub-header"><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#唤醒后继节点" class="sidebar-link">唤醒后继节点</a></li><li class="sidebar-sub-header"><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#唤醒阻塞后流程" class="sidebar-link">唤醒阻塞后流程</a></li></ul></li><li><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#阅读源码小技巧" class="sidebar-link">阅读源码小技巧</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/thread/%E8%81%8A%E4%B8%80%E8%81%8AReentrantLock%E5%92%8CAQS%E9%82%A3%E7%82%B9%E4%BA%8B.html#后记" class="sidebar-link">后记</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>男生魅力最重要的部分，<strong>是有勇气面对失败</strong>；而生活的美好之处，<strong>恰恰在于它的不确定性</strong></p> <p>AbstractQueuedSynchronizer（AQS）是 Java 并发编程中绕不过去的一道坎，JUC 并发包下的 Lock、Semaphore、ReentrantLock 等都是基于 AQS 实现的。AQS 是一个抽象的同步框架，提供了原子性管理同步状态，基于阻塞队列模型实现阻塞和唤醒等待线程的功能</p> <p>文章从 ReentrantLock 加锁、解锁应用 API 入手，逐步讲解 AQS 对应源码以及相关隐含流程</p> <p>列出本篇文章大纲以及相关知识点，方便大家更好的理解</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201115144318438.png" alt=""></p> <h2 id="什么是-reentrantlock"><a href="#什么是-reentrantlock" class="header-anchor">#</a> 什么是 ReentrantLock</h2> <p>ReentrantLock 翻译为 <strong>可重入锁</strong>，指的是一个线程能够对 <strong>临界区共享资源进行重复加锁</strong></p> <p>确保线程安全最常见的做法是利用锁机制（Lock、sychronized）来对 <strong>共享数据做互斥同步</strong>，这样在同一个时刻，只有 <strong>一个线程可以执行某个方法或者某个代码块</strong>，那么操作必然是 <strong>原子性的，线程安全的</strong></p> <p>这里就有个疑问，因为 JDK 中关键字 <strong>synchronized</strong> 也能同时支持原子性以及线程安全</p> <p><strong>有了 synchronized 关键字后为什么还需要 ReentrantLock?</strong></p> <p>为了大家更好的掌握 ReentrantLock 源码，这里列出两种锁之间的区别</p> <table><thead><tr><th style="text-align:center;"></th> <th style="text-align:center;">Synchronized</th> <th style="text-align:center;">ReentrantLock</th></tr></thead> <tbody><tr><td style="text-align:center;">锁实现机制</td> <td style="text-align:center;">对象头监视器模式</td> <td style="text-align:center;">依赖 AQS</td></tr> <tr><td style="text-align:center;">灵活性</td> <td style="text-align:center;">不灵活</td> <td style="text-align:center;">支持响应中断、超时、尝试获取锁</td></tr> <tr><td style="text-align:center;">释放锁形式</td> <td style="text-align:center;">自动释放锁</td> <td style="text-align:center;">显示调用 unlock()</td></tr> <tr><td style="text-align:center;">支持锁类型</td> <td style="text-align:center;">非公平锁</td> <td style="text-align:center;">公平锁 &amp; 非公平锁</td></tr> <tr><td style="text-align:center;">条件队列</td> <td style="text-align:center;">单条件队列</td> <td style="text-align:center;">多个条件队列</td></tr> <tr><td style="text-align:center;">是否支持可重入</td> <td style="text-align:center;">支持</td> <td style="text-align:center;">支持</td></tr></tbody></table> <br> <p>通过以上六个维度比对，可以看出 ReentrantLock 是要比 synchronized <strong>灵活以及支持功能更丰富</strong></p> <h2 id="什么是-aqs"><a href="#什么是-aqs" class="header-anchor">#</a> 什么是 AQS</h2> <p>AQS（ AbstractQueuedSynchronizer ）是一个用来构建锁和同步器的抽象框架，只需要继承 AQS 就可以很方便的实现我们自定义的多线程同步器、锁</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114220450839.png" alt=""></p> <p>如图所示，在 <strong>java.util.concurrent</strong> 包下相关锁、同步器（常用的有 ReentrantLock、 ReadWriteLock、CountDownLatch...）都是基于 AQS 来实现</p> <p><strong>AQS 是典型的模板方法设计模式</strong>，父类（AQS）定义好骨架和内部操作细节，具体规则由子类去实现</p> <h3 id="aqs-核心原理"><a href="#aqs-核心原理" class="header-anchor">#</a> AQS 核心原理</h3> <p>如果被请求的共享资源未被占用，将当前请求资源的线程设置为独占线程，并将共享资源设置为锁定状态</p> <p>AQS 使用一个 Volatile 修饰的 int 类型的成员变量 State 来表示同步状态，修改同步状态成功即为获得锁</p> <p>Volatile 保证了变量在多线程之间的可见性，修改 State 值时通过 CAS 机制来保证修改的原子性</p> <p>如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到一个变体的 CLH 队列中</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201115014812244.png" alt=""></p> <p>关于支撑 AQS 特性的重要方法及属性如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractQueuedSynchronizer</span> 
  <span class="token keyword">extends</span> <span class="token class-name">AbstractOwnableSynchronizer</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span>
  	<span class="token comment">// CLH 变体队列头、尾节点</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> head<span class="token punctuation">;</span>
  	<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> tail<span class="token punctuation">;</span>
  	<span class="token comment">// AQS 同步状态</span>
   	<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span>
  	<span class="token comment">// CAS 方式更新 state</span>
  	<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="clh-队列"><a href="#clh-队列" class="header-anchor">#</a> CLH 队列</h3> <p>既然是 AQS 中使用的是 CLH 变体队列，我们先来了解下 CLH 队列是什么</p> <p>CLH：Craig、Landin and Hagersten 队列，是 <strong>单向链表实现的队列</strong>。申请线程只在本地变量上自旋，<strong>它不断轮询前驱的状态</strong>，如果发现 <strong>前驱节点释放了锁就结束自旋</strong></p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201107234158422.png" alt=""></p> <p>通过对 CLH 队列的说明，可以得出以下结论</p> <ol><li>CLH 队列是一个单向链表，保持 FIFO 先进先出的队列特性</li> <li>通过 tail 尾节点（原子引用）来构建队列，总是指向最后一个节点</li> <li>未获得锁节点会进行自旋，而不是切换线程状态</li> <li>并发高时性能较差，因为未获得锁节点不断轮训前驱节点的状态来查看是否获得锁</li></ol> <p>AQS 中的队列是 CLH 变体的虚拟双向队列，通过将每条请求共享资源的线程封装成一个节点来实现锁的分配</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114161720040.png" alt=""></p> <p>相比于 CLH 队列而言，AQS 中的 CLH 变体等待队列拥有以下特性</p> <ol><li>AQS 中队列是个双向链表，也是 FIFO 先进先出的特性</li> <li>通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性</li> <li>Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程</li> <li>获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好</li></ol> <h3 id="认识-aos"><a href="#认识-aos" class="header-anchor">#</a> 认识 AOS</h3> <p>抽象类 AQS 同样继承自抽象类 AOS（AbstractOwnableSynchronizer）</p> <p>AOS 内部只有一个 Thread 类型的变量，提供了获取和设置当前独占锁线程的方法</p> <p>主要作用是 <strong>记录当前占用独占锁（互斥锁）的线程实例</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractOwnableSynchronizer</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span>
    <span class="token comment">// 独占线程（不参与序列化）</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Thread</span> exclusiveOwnerThread<span class="token punctuation">;</span>
    <span class="token comment">// 设置当前独占的线程</span>
    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        exclusiveOwnerThread <span class="token operator">=</span> thread<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回当前独占的线程</span>
    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token class-name">Thread</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> exclusiveOwnerThread<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="为什么要掌握-aqs"><a href="#为什么要掌握-aqs" class="header-anchor">#</a> 为什么要掌握 AQS</h3> <p>如何能够体现程序员的水平，那就是掌握大多数人所不掌握的技术，这也是为什么面试时 AQS 高频出现的原因，因为它不简单</p> <p>最初接触 ReentrantLock 以及 AQS 的时候，看到源码就是一头雾水，Debug 跟着跟着就 <strong>迷失了自己</strong>，相信这也是大多数人的反应</p> <p>正是因为经历过，所以才能从小白的心理上出发，把其中的知识点能够尽数梳理</p> <p>作者写的很用心，看过这篇文章的小伙伴，不敢保证百分百理解 AQS 和 ReentrantLock 的原理，但是一定会有所收获</p> <h2 id="独占加锁源码解析"><a href="#独占加锁源码解析" class="header-anchor">#</a> 独占加锁源码解析</h2> <h3 id="什么是独占锁"><a href="#什么是独占锁" class="header-anchor">#</a> 什么是独占锁</h3> <p>独占锁也叫排它锁，是指该锁一次只能被一个线程所持有，如果别的线程想要获取锁，只有等到持有锁线程释放</p> <p>获得排它锁的线程即能读数据又能修改数据，与之对立的就是共享锁</p> <p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁</p> <p>获得共享锁的线程只能读数据，不能修改数据</p> <h3 id="独占锁加锁"><a href="#独占锁加锁" class="header-anchor">#</a> 独占锁加锁</h3> <p>ReentrantLock 就是独占锁的一种实现方式，接下来看代码中如何使用 ReentrantLock 完成独占式加锁业务逻辑</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建非公平锁</span>
    <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取锁操作</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 执行代码逻辑</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment">// 解锁操作</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>new ReentrantLock() 构造函数默认创建的是非公平锁 NonfairSync</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">--</span><span class="token operator">-</span> <span class="token class-name">ReentrantLock</span>
<span class="token comment">// true 代表公平锁，false 代表非公平锁</span>
<span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义</p> <p><strong>公平锁 FairSync</strong></p> <ol><li>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁</li> <li>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大</li></ol> <p><strong>非公平锁 NonfairSync</strong></p> <ol><li>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁</li> <li>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁</li></ol> <p>两者的都继承自 ReentrantLock 静态抽象内部类 Sync，<strong>Sync 类继承自 AQS</strong>，这里就有个疑问</p> <p>这些锁都没有直接继承 AQS，而是定义了一个 <strong>Sync 类去继承 AQS</strong>，为什么要这样呢？</p> <p>因为 <strong>锁面向的是使用用户</strong>，<strong>同步器面向的则是线程控制</strong>，那么在锁的实现中聚合同步器而不是直接继承 AQS 就可以很好的 <strong>隔离二者所关注的事情</strong></p> <p>通过对不同锁种类的讲解以及 ReentrantLock 内部结构的解析，根据上下级关系继承图，加深其理解</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201106104059148.png" alt=""></p> <p>这里以非公平锁举例，查看加锁的具体过程，详细信息下文会详细说明</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201117222132211.png" alt=""></p> <p>看一下非公平锁加锁方法 lock 内部怎么做的</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">--</span><span class="token operator">-</span> <span class="token class-name">ReentrantLock</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sync<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">-</span> <span class="token class-name">Sync</span>
<span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>Sync#lock</strong> 为抽象方法，最终会调用其子类非公平锁的方法 lock</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>非公平加锁方法有两个逻辑</p> <ol><li>通过比较并替换 State（同步状态）成功与否决定是否获得锁，设置 State 为 1表示成功获取锁，并将当前线程设置为独占线程</li> <li>修改 State 值失败则进入尝试获取锁流程，acquire 方法为 AQS 提供的方法</li></ol> <p>compareAndSetState 以 CAS 比较并替换的方式将 State 值设置为 1，表示同步状态被占用</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// See below for intrinsics setup to support this</span>
    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token class-name">StateOffset</span><span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>setExclusiveOwnerThread 设置当前线程为独占锁拥有线程</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>    exclusiveOwnerThread <span class="token operator">=</span> thread<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>acquire 对整个 AQS 做到了承上启下的作用，通过 tryAcquire 模版方法进行尝试获取锁，获取锁失败包装当前线程为 Node 节点加入等待队列排队</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>tryAcquire 是 AQS 中抽象模版方法，但是内部会有默认实现，虽然默认的方法内部抛出异常，<strong>为什么不直接定义为抽象方法呢?</strong></p> <p>因为 AQS 不只是对独占锁实现了抽象，同时还包括共享锁；不同锁定义了不同类别的方法，共享锁就不需要 tryAcquire，如果定义为抽象方法，继承 AQS 子类都需要实现该方法</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>NonfairSync 类中有 tryAcquire 重写方法，继续查看具体如何进行非公平方式获取锁</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  	<span class="token comment">// State 等于0表示此时无锁    if (c == 0) {      	// 再次使用CAS尝试获取锁, 表现为非公平锁特性        if (compareAndSetState(0, acquires)) {          	// 设置线程为独占锁线程            setExclusiveOwnerThread(current);            return true;        }    // 如果当前线程等于已获取锁线程, 表现为可重入锁特性    } else if (current == getExclusiveOwnerThread()) {        int nextc = c + acquires;        if (nextc &lt; 0) // overflow            throw new Error(&quot;Maximum lock count exceeded&quot;);      	// 设置 State        setState(nextc);        return true;    }  	// 如果state不等于0并且独占线程不是当前线程, 返回 false    return false;}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>由于 tryAcquire 做了取反，如果设置 state 失败并且独占锁线程不是自己本身返回 false，通过取反会进入接下来的流程</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="node-入队流程"><a href="#node-入队流程" class="header-anchor">#</a> Node 入队流程</h3> <p>尝试获得锁失败，接下来会将线程组装成为 Node 进行入队流程</p> <p>Node 是 AQS 中最基本的数据结构，也是 CLH 变体队列中的节点，Node 有 <strong>SHARED（共享）、EXCLUSIVE（独占）</strong> 两种模式，文章主要介绍 EXCLUSIVE 模式，不相关的属性和方法不予介绍</p> <p>下面列出关于 Node EXCLUSIVE 模式的一些关键方法以及状态信息</p> <table><thead><tr><th style="text-align:center;">关键方法与属性</th> <th style="text-align:center;">对应含义</th></tr></thead> <tbody><tr><td style="text-align:center;">waitStatus</td> <td style="text-align:center;">当前节点在队列中处于什么状态</td></tr> <tr><td style="text-align:center;">thread</td> <td style="text-align:center;">表示节点对应的线程</td></tr> <tr><td style="text-align:center;">prev</td> <td style="text-align:center;">前驱指针，指向本节点的上一个节点</td></tr> <tr><td style="text-align:center;">next</td> <td style="text-align:center;">后继指针，指向本节点的下一个节点</td></tr> <tr><td style="text-align:center;">predecessor</td> <td style="text-align:center;">返回前驱节点，没有的话抛出 NPE 异常</td></tr></tbody></table> <p>Node 中独占锁相关的 waitStatus 属性分别有以下几种状态</p> <table><thead><tr><th style="text-align:center;">属性值</th> <th style="text-align:center;">值含义</th></tr></thead> <tbody><tr><td style="text-align:center;">0</td> <td style="text-align:center;">Node 被初始化后的默认值</td></tr> <tr><td style="text-align:center;">CANCELLED</td> <td style="text-align:center;">值为1，由于中断或超时，节点被取消</td></tr> <tr><td style="text-align:center;">SIGNAL</td> <td style="text-align:center;">值为-1，表示节点的后继节点即将被阻塞</td></tr> <tr><td style="text-align:center;">CONDITION</td> <td style="text-align:center;">值为-2，表示节点在等待队列中，节点线程等待唤醒</td></tr></tbody></table> <p>介绍完 Node 相关基础知识，看一下请求锁线程如何被包装为 Node，又是如何初始化入队的</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取等待队列的尾节点    Node pred = tail;  	// 如果尾节点不为空, 将 node 设置为尾节点, 并将原尾节点 next 指向 新的尾节点node    if (pred != null) {        node.prev = pred;        if (compareAndSetTail(pred, node)) {            pred.next = node;            return node;        }    }  	// 尾部为空，enq 执行    enq(node);    return node;}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>pred 为队列的尾节点，根据尾节点是否为空会执行对应流程</p> <ol><li>尾节点不为空，证明队列已被初始化，那么需要将对应的 node（当前线程）设置为新的尾节点，也就是入队操作；将 node 节点的前驱指针指向 pred（尾节点），并将 node 通过 CAS 方式设置为 AQS 等待队列的尾节点，替换成功后将原来的尾节点后继指针指向新的尾节点</li> <li>尾节点为空，证明还没有初始化队列，执行 enq 方法进行初始化队列</li></ol> <p>enq 方法执行初始化队列操作，等待队列中虚拟化的头节点也是在这里产生</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          	<span class="token comment">// 虚拟化一个空Node, 并将head指向空Node            if (compareAndSetHead(new Node()))              	// 将尾节点等于头节点                tail = head;        } else {          	// node上一条指向尾节点            node.prev = t;          	// 设置node为尾节点            if (compareAndSetTail(t, node)) {              	// 设置原尾节点的下一条指向node                t.next = node;                return t;            }        }    }}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>执行 enq 方法的前提就是队列尾节点为空，为什么还要再判断尾节点是否为空？</strong></p> <p>因为 enq 方法中是一个死循环，循环过程中 t 的值是不固定的。假如执行 enq 方法时队列为空，for 循环会执行两遍不同的处理逻辑</p> <ol><li>尾节点为空，虚拟化出一个新的 Node 头节点，这时队列中只有一个元素，为了保证 AQS 队列结构的完整性，会将尾节点指向头节点，第一遍循环结束</li> <li>第二遍不满足尾节点为空条件，执行 else 语句块，node 节点前驱指针指向尾节点，并将 node 通过 CAS 设置为新的尾节点，成功后设置原尾节点的后继指针指向 node，至此入队成功。返回的 t 无意义，只是为了终止死循环</li></ol> <p>画两张图来理解 enq 方法整体初始化 AQS 队列流程，假设T1、T2两个线程争取锁，T1成功获得锁，T2进行入队操作</p> <ol><li>T2进行入队操作，循环第一遍，尾节点为空。开始初始化头节点，并将尾节点指向头节点，最终队列形式是这样纸滴</li></ol> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114213221013.png" alt=""></p> <ol start="2"><li>循环第二遍，需要将 node 设置为新的尾节点。逻辑如下：尾节点不为空，设置 node 前驱指针指向尾节点，并将 node 设置为尾节点，原尾节点 next 指针指向 node</li></ol> <p>addWaiter 方法就是为了让 Node 入队，并且维护出一个双向队列模型</p> <p>入队执行成功后，会在 acquireQueued 再次尝试竞争锁，竞争失败后会将线程阻塞</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>acquireQueued 方法会尝试自旋获取锁，获取失败对当前线程实施阻塞流程，这也是为了避免无意义的自旋，对比 CLH 队列性能优化的体现</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>          	<span class="token comment">// 获取node上一个节点            final Node p = node.predecessor();          	// 如果node为头节点 &amp; 尝试获取锁成功            if (p == head &amp;&amp; tryAcquire(arg)) {              	// 此时当前node线程获取到了锁              	// 将node设置为新的头节点                setHead(node);              	// help GC                p.next = null;                failed = false;                return interrupted;            }            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())                interrupted = true;        }    } finally {        if (failed)            cancelAcquire(node);    }}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>通过 node.predecessor() 获取节点的前驱节点，前驱节点为空抛出空指针异常</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NullPointerException</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span> p <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>获取到前驱节点后进行两步逻辑判断</p> <ol><li>判断前驱节点 p 是否为头节点，为 true 进行尝试获取锁，获取锁成功设置当前节点为新的头节点，并将原头节点的后驱指针设为空</li> <li>前驱节点不是头节点或者尝试加锁失败，执行线程休眠阻塞操作</li></ol> <p>如果 node 获得锁后，setHead 将节点设置为队列头，从而实现出队效果，出于 GC 的考虑，清空未使用的数据</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setHead</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    head <span class="token operator">=</span> node<span class="token punctuation">;</span>    node<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    node<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>shouldParkAfterFailedAcquire 需要重点关注下，流程相对比较难理解</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span><span class="token class-name">Node</span> pred<span class="token punctuation">,</span> <span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>ws 表示为当前申请锁节点前驱节点的等待状态，代码中包含三个逻辑，分别是：</p> <ol><li>ws == Node.SIGNAL，表示需要将申请锁节点进行阻塞</li> <li>ws &gt; 0，表示等待队列中包含被取消节点，需要调整队列</li> <li>如果 ws == Node.SIGNAL || ws &gt;0 都为 false，使用 CAS 的方式将前驱节点等待状态设置为 Node.SIGNAL</li></ol> <blockquote><p>设置当前节点的前置节点等待状态为 Node.SIGNAL，表示当前节点获取锁失败，需要进行阻塞操作</p></blockquote> <p>还是通过几张图来理解流程，假设此时 T1、T2 线程来争夺锁</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114213609335.png" alt=""></p> <p>T1 线程获得锁，T2 进入 AQS 等待队列排队，并通过 CAS 将 T2 节点的前驱节点等待状态置为 SIGNAL</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201109140133492.png" alt=""></p> <p>执行切换前驱节点等待状态后返回 false，继续进行循环尝试获取同步状态</p> <blockquote><p>这一步操作保证了线程能进行多次重试，尽量避免线程状态切换</p></blockquote> <p>如果 T1 线程没有释放锁，T2 线程第二次执行到 shouldParkAfterFailedAcquire 方法，因为前驱节点已设置为 SIGNAL，所以会直接返回 true，执行线程阻塞操作</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  	<span class="token comment">// 将当前线程进行阻塞    LockSupport.park(this);  	// 方法返回了当前线程的中断状态，并将当前线程的中断标识设置为false    return Thread.interrupted();}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>LockSupport.park 方法将当前等待队列中线程进行阻塞操作，线程执行一个从 RUNNABLE 到 WAITING 状态转变</p> <p>如果线程被唤醒，通过执行 Thread.interrupted 查看中断状态，这里的中断状态会被传递到 acquire 方法</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>      	<span class="token comment">// 如果线程被中断, 这里会再次设置中断状态      	// 因为如果线程中断, 调用 Thread.interrupted 虽然会返回 true, 但是会清除线程中断状态        selfInterrupt();}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>即使线程从 park 方法中唤醒后发现自己被中断了，但是不影响接下来的获取锁操作，如果需要设置线程中断来影响流程，可以使用 lockInterruptibly 获得锁，抛出检查异常 InterruptedException</p> <h3 id="cancelacquire"><a href="#cancelacquire" class="header-anchor">#</a> cancelAcquire</h3> <p>取消排队方法是 AQS 中比较难的知识点，不容易被理解</p> <p>当线程因为自旋或者异常等情况获取锁失败，会调用此方法进行取消正在获取锁的操作</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">cancelAcquire</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 不存在的节点直接返回    if (node == null)        return;    node.thread = null;    /**     * waitStatus &gt; 0 代表节点为取消状态     * while循环会将node节点的前驱指针指向一个非取消状态的节点     * pred等于当前节点的前驱节点（非取消状态）     */    Node pred = node.prev;    while (pred.waitStatus &gt; 0)        node.prev = pred = pred.prev;    // 获取过滤后的前驱节点的后继节点    Node predNext = pred.next;    // 设置node等待状态为取消状态    node.waitStatus = Node.CANCELLED;    // 🚩步骤一，如果node是尾节点，使用CAS将pred设置为新的尾节点  	    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) {      	// 设置pred（新tail）的后驱指针为空        compareAndSetNext(pred, predNext, null);    } else {        int ws;      	// 🚩步骤二，node的前驱节点pred（非取消状态）!= 头节点        if (pred != head             	/**            	 * 1. pred等待状态等于SIGNAL            	 * 2. ws &lt;= 0并且设置pred等待状态为SIGNAL            	 */            	&amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL)))             	// pred中线程不为空            	&amp;&amp; pred.thread != null) {            Node next = node.next;          	/**          	 * 1. 当前节点的后继节点不为空          	 * 2. 后继节点等待状态&lt;=0（表示非取消状态）          	 */            if (next != null &amp;&amp; next.waitStatus &lt;= 0)              	// 设置pred的后继节点设置为当前节点的后继节点                compareAndSetNext(pred, predNext, next);        } else {          	// 🚩步骤三，如果当前节点为头节点或者上述条件不满足, 执行唤醒当前节点的后继节点流程            unparkSuccessor(node);        }        node.next = node; // help GC    }}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>逻辑稍微复杂一些，比较重要是以下三个逻辑</p> <ol><li><p>步骤一当前节点为尾节点的话，设置 pred 节点为新的尾节点，成功设置后再将 pred 后继节点设置为空（尾节点不会有后继节点）</p></li> <li><p>步骤二需要满足以下四个条件才会将前驱节点（非取消状态）的后继指针指向当前节点的后继指针</p> <p>1）当前节点不等于尾节点</p> <p>2）当前节点前驱节点不等于头节点</p> <p>3）前驱节点的等待状态不为取消状态</p> <p>4）前驱节点的拥有线程不为空</p></li> <li><p>如果不满足步骤二的话，会执行步骤三相关逻辑，唤醒后继节点</p></li></ol> <p><strong>步骤一：</strong></p> <p>假设当前取消节点为尾节点并且前置节点无取消节点，现有等待队列如下图，执行下述逻辑</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> tail <span class="token operator">&amp;&amp;</span> <span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> pred<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">compareAndSetNext</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> predNext<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201112180208027.png" alt=""></p> <p>将 pred 设置为新的尾节点，并将 pred 后继节点设置为空，因为尾节点不会有后继节点了</p> <p>T4 线程所在节点因无引用指向，会被 GC 垃圾回收处理</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114141417895.png" alt=""></p> <p><strong>步骤二：</strong></p> <p>如果当前需要取消节点的前驱节点为取消状态节点，如图所示</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114140258406.png" alt=""></p> <p>设置 pred（非取消状态）的后继节点为 node 的后继节点，并设置 node 的 next 为 自己本身</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114141329010.png" alt=""></p> <p><strong>线程T2、T3所在节点因为被T4所直接或间接指向，如何进行GC?</strong></p> <p>AQS 等待队列中取消状态节点会在 shouldParkAfterFailedAcquire 方法中被 GC 垃圾回收</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>T4 线程所在节点获取锁失败尝试停止时，会执行上述代码，执行后的等待队列如下图所示</p> <p><img src="https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114144243192.png" alt=""></p> <p>等待队列中取消状态节点就可以被 GC 垃圾回收了，至此加锁流程也就结束了，下面继续看如何解锁</p> <h2 id="独占解锁源码解析"><a href="#独占解锁源码解析" class="header-anchor">#</a> 独占解锁源码解析</h2> <p>解锁流程相对于加锁简单了很多，调用对应API-lock.unlock()</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token operator">--</span><span class="token operator">-</span> <span class="token class-name">ReentrantLockpublic</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">--</span><span class="token operator">-</span> <span class="token class-name">AQSpublic</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  	<span class="token comment">// 尝试释放锁    if (tryRelease(arg)) {        Node h = head;        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    }    return false;}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="释放锁同步状态"><a href="#释放锁同步状态" class="header-anchor">#</a> 释放锁同步状态</h3> <p>tryRelease 是定义在 AQS 中的抽象方法，通过 Sync 类重写了其实现</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>  	<span class="token comment">// 如果当前线程不等于拥有锁线程, 抛出异常    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    boolean free = false;    if (c == 0) {        free = true;      	// 将拥有锁线程设置为空        setExclusiveOwnerThread(null);    }  	// 设置State状态为0, 解锁成功    setState(c);    return free;}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="唤醒后继节点"><a href="#唤醒后继节点" class="header-anchor">#</a> 唤醒后继节点</h3> <p>此时 State 值已被释放，对于头节点的判断这块流程比较有意思</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>		<span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>什么情况下头节点为空</strong>，当线程还在争夺锁，队列还未初始化，头节点必然是为空的</p> <p>当头节点等待状态等于0，证明后继节点还在自旋，不需要进行后继节点唤醒</p> <p>如果同时满足上述两个条件，会对等待队列头节点的后继节点进行唤醒操作</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>  	<span class="token comment">// 获取node等待状态    int ws = node.waitStatus;    if (ws &lt; 0)        compareAndSetWaitStatus(node, ws, 0);  	// 获取node的后继节点    Node s = node.next;  	// 如果下个节点为空或者被取消, 遍历队列查询非取消节点    if (s == null || s.waitStatus &gt; 0) {        s = null;      	// 从队尾开始查找, 等待状态 &lt;= 0 的节点        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)            if (t.waitStatus &lt;= 0)                s = t;    }  	// 满足 s != null &amp;&amp; s.waitStatus &lt;= 0  	// 执行 unpark    if (s != null)        LockSupport.unpark(s.thread);}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>为什么查找队列中未被取消的节点需要从尾部开始？</strong></p> <p>这个问题有两个原因可以解释，分别是 Node 入队和清理取消状态的节点</p> <ol><li><p>先从 addWaiter 入队时说起，compareAndSetTail(pred, node)、pred.next = node 并非原子操作，如果在执行 pred.next = node 前进行 unparkSuccessor，就没有办法通过 next 指针向后遍历，所以才会从后向前找寻非取消的节点</p></li> <li><p>cancelAcquire 方法也有导致使用 head 无法遍历全部 Node 的因素，因为先断开的是 next 指针，prev 指针并未断开</p></li></ol> <h3 id="唤醒阻塞后流程"><a href="#唤醒阻塞后流程" class="header-anchor">#</a> 唤醒阻塞后流程</h3> <p>当线程获取锁失败被 park 后进入了阻塞模式，前驱节点释放锁后会进行唤醒 unpark，被阻塞线程状态回归 RUNNABLE 状态</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  	<span class="token comment">// 从此位置唤醒    LockSupport.park(this);    return Thread.interrupted();}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>被唤醒线程检查自身是否被中断，返回自身中断状态到 acquireQueued</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC                failed = false;                return interrupted;            }            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())                interrupted = true;        }    } finally {        if (failed)            cancelAcquire(node);    }}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>假设自身被中断，设置 interrupted = true，继续通过循环尝试获取锁，获取锁成功后返回 interrupted 中断状态</p> <p><strong>中断状态本身并不会对加锁流程产生影响</strong>，被唤醒后还是会不断进行获取锁，直到获取锁成功进行返回，返回中断状态是为了后续补充中断纪录</p> <p>如果线程被唤醒后发现中断，成功获取锁后会将中断状态返回，补充中断状态</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>selfInterrupt 就是对线程中断状态的一个补充，补充状态成功后，流程结束</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="阅读源码小技巧"><a href="#阅读源码小技巧" class="header-anchor">#</a> 阅读源码小技巧</h2> <p><strong>1、从全局掌握要阅读的源码提供了什么功能</strong></p> <p>这也是我一直推崇的学习源码方式，学习源码的关键点是抓住主线流程，在了解主线之前不要最开始就研究到源码实现细节中，否则很容易迷失在细枝末节的代码中</p> <p>以文章中的 AQS 举例，当你知道了它是一个抽象队列同步器，使用它可以更简单的构造锁和同步器等实现</p> <p>然后从中理解 tryAcquire、tryRelease 等方法实现，这样是不是可以更好的理解与 AQS 与其子类相关的代码</p> <p><strong>2、把不易理解的源码粘贴出来，整理好格式打好备注</strong></p> <p>一般源码中的行为格式和我们日常敲代码是不一样的，而且 JDK 源码中的变量命名实在是惨不忍睹</p> <p>所以就应该将难以理解的源码粘贴出，标上对应注释以及调整成易理解的格式，这样对于源码的阅读就会轻松很多</p> <h2 id="后记"><a href="#后记" class="header-anchor">#</a> 后记</h2> <p>平常工作中接触到 AQS 相关知识还是很多的，知其然知其所以然，文章以 ReentrantLock 作为切入点，讲述了其公平锁和非公平锁的概念，以及对应 AQS 中 CLH、AOS 等不容易被发现的概念</p> <p>针对 ReentrantLock 以及 AQS 加锁、解锁、排队等流程进行了详细说明，以图文并茂的方式讲述了其流程源码实现细节，这里希望在看的小伙伴都能收获 AQS 相关知识</p> <p><strong>由于作者水平有限, 欢迎大家能够反馈指正文章中错误不正确的地方, 感谢 🙏</strong></p> <p>小伙伴的喜欢就是对我最大的支持, 如果读了文章有所收获, 希望能够 <strong>点赞、评论、关注三连!</strong></p> <p>参考资料</p> <ul><li>https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</li> <li>https://tech.meituan.com/2018/11/15/java-lock.html</li> <li>https://mp.weixin.qq.com/s/y_e3ciU-hiqlb5vseuOFyw</li> <li>https://zhuanlan.zhihu.com/p/197840259?utm_source=wechat_session</li> <li>https://blog.csdn.net/java_lyvee/article/details/98966684</li> <li>https://zhuanlan.zhihu.com/p/197840259?utm_source=wechat_session</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9f6db045.js" defer></script><script src="/assets/js/2.ad010850.js" defer></script><script src="/assets/js/41.d75e30b9.js" defer></script>
  </body>
</html>
