(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{403:function(t,s,a){"use strict";a.r(s);var n=a(45),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("男生魅力最重要的部分，"),a("strong",[t._v("是有勇气面对失败")]),t._v("；而生活的美好之处，"),a("strong",[t._v("恰恰在于它的不确定性")])]),t._v(" "),a("p",[t._v("AbstractQueuedSynchronizer（AQS）是 Java 并发编程中绕不过去的一道坎，JUC 并发包下的 Lock、Semaphore、ReentrantLock 等都是基于 AQS 实现的。AQS 是一个抽象的同步框架，提供了原子性管理同步状态，基于阻塞队列模型实现阻塞和唤醒等待线程的功能")]),t._v(" "),a("p",[t._v("文章从 ReentrantLock 加锁、解锁应用 API 入手，逐步讲解 AQS 对应源码以及相关隐含流程")]),t._v(" "),a("p",[t._v("列出本篇文章大纲以及相关知识点，方便大家更好的理解")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201115144318438.png",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"什么是-reentrantlock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-reentrantlock"}},[t._v("#")]),t._v(" 什么是 ReentrantLock")]),t._v(" "),a("p",[t._v("ReentrantLock 翻译为 "),a("strong",[t._v("可重入锁")]),t._v("，指的是一个线程能够对 "),a("strong",[t._v("临界区共享资源进行重复加锁")])]),t._v(" "),a("p",[t._v("确保线程安全最常见的做法是利用锁机制（Lock、sychronized）来对 "),a("strong",[t._v("共享数据做互斥同步")]),t._v("，这样在同一个时刻，只有 "),a("strong",[t._v("一个线程可以执行某个方法或者某个代码块")]),t._v("，那么操作必然是 "),a("strong",[t._v("原子性的，线程安全的")])]),t._v(" "),a("p",[t._v("这里就有个疑问，因为 JDK 中关键字 "),a("strong",[t._v("synchronized")]),t._v(" 也能同时支持原子性以及线程安全")]),t._v(" "),a("p",[a("strong",[t._v("有了 synchronized 关键字后为什么还需要 ReentrantLock?")])]),t._v(" "),a("p",[t._v("为了大家更好的掌握 ReentrantLock 源码，这里列出两种锁之间的区别")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}}),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("Synchronized")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("ReentrantLock")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("锁实现机制")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("对象头监视器模式")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("依赖 AQS")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("灵活性")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("不灵活")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("支持响应中断、超时、尝试获取锁")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("释放锁形式")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("自动释放锁")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("显示调用 unlock()")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("支持锁类型")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("非公平锁")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("公平锁 & 非公平锁")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("条件队列")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("单条件队列")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("多个条件队列")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("是否支持可重入")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("支持")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("支持")])])])]),t._v(" "),a("br"),t._v(" "),a("p",[t._v("通过以上六个维度比对，可以看出 ReentrantLock 是要比 synchronized "),a("strong",[t._v("灵活以及支持功能更丰富")])]),t._v(" "),a("h2",{attrs:{id:"什么是-aqs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-aqs"}},[t._v("#")]),t._v(" 什么是 AQS")]),t._v(" "),a("p",[t._v("AQS（ AbstractQueuedSynchronizer ）是一个用来构建锁和同步器的抽象框架，只需要继承 AQS 就可以很方便的实现我们自定义的多线程同步器、锁")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114220450839.png",alt:""}})]),t._v(" "),a("p",[t._v("如图所示，在 "),a("strong",[t._v("java.util.concurrent")]),t._v(" 包下相关锁、同步器（常用的有 ReentrantLock、 ReadWriteLock、CountDownLatch...）都是基于 AQS 来实现")]),t._v(" "),a("p",[a("strong",[t._v("AQS 是典型的模板方法设计模式")]),t._v("，父类（AQS）定义好骨架和内部操作细节，具体规则由子类去实现")]),t._v(" "),a("h3",{attrs:{id:"aqs-核心原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aqs-核心原理"}},[t._v("#")]),t._v(" AQS 核心原理")]),t._v(" "),a("p",[t._v("如果被请求的共享资源未被占用，将当前请求资源的线程设置为独占线程，并将共享资源设置为锁定状态")]),t._v(" "),a("p",[t._v("AQS 使用一个 Volatile 修饰的 int 类型的成员变量 State 来表示同步状态，修改同步状态成功即为获得锁")]),t._v(" "),a("p",[t._v("Volatile 保证了变量在多线程之间的可见性，修改 State 值时通过 CAS 机制来保证修改的原子性")]),t._v(" "),a("p",[t._v("如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到一个变体的 CLH 队列中")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201115014812244.png",alt:""}})]),t._v(" "),a("p",[t._v("关于支撑 AQS 特性的重要方法及属性如下：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("abstract")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AbstractQueuedSynchronizer")]),t._v(" \n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AbstractOwnableSynchronizer")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("java"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("io"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")])]),t._v("Serializable")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// CLH 变体队列头、尾节点")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("transient")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" head"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  \t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("transient")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" tail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// AQS 同步状态")]),t._v("\n   \t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// CAS 方式更新 state")]),t._v("\n  \t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSetState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" expect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" update"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" unsafe"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSwapInt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" stateOffset"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" expect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" update"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br")])]),a("h3",{attrs:{id:"clh-队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clh-队列"}},[t._v("#")]),t._v(" CLH 队列")]),t._v(" "),a("p",[t._v("既然是 AQS 中使用的是 CLH 变体队列，我们先来了解下 CLH 队列是什么")]),t._v(" "),a("p",[t._v("CLH：Craig、Landin and Hagersten 队列，是 "),a("strong",[t._v("单向链表实现的队列")]),t._v("。申请线程只在本地变量上自旋，"),a("strong",[t._v("它不断轮询前驱的状态")]),t._v("，如果发现 "),a("strong",[t._v("前驱节点释放了锁就结束自旋")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201107234158422.png",alt:""}})]),t._v(" "),a("p",[t._v("通过对 CLH 队列的说明，可以得出以下结论")]),t._v(" "),a("ol",[a("li",[t._v("CLH 队列是一个单向链表，保持 FIFO 先进先出的队列特性")]),t._v(" "),a("li",[t._v("通过 tail 尾节点（原子引用）来构建队列，总是指向最后一个节点")]),t._v(" "),a("li",[t._v("未获得锁节点会进行自旋，而不是切换线程状态")]),t._v(" "),a("li",[t._v("并发高时性能较差，因为未获得锁节点不断轮训前驱节点的状态来查看是否获得锁")])]),t._v(" "),a("p",[t._v("AQS 中的队列是 CLH 变体的虚拟双向队列，通过将每条请求共享资源的线程封装成一个节点来实现锁的分配")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114161720040.png",alt:""}})]),t._v(" "),a("p",[t._v("相比于 CLH 队列而言，AQS 中的 CLH 变体等待队列拥有以下特性")]),t._v(" "),a("ol",[a("li",[t._v("AQS 中队列是个双向链表，也是 FIFO 先进先出的特性")]),t._v(" "),a("li",[t._v("通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性")]),t._v(" "),a("li",[t._v("Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程")]),t._v(" "),a("li",[t._v("获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好")])]),t._v(" "),a("h3",{attrs:{id:"认识-aos"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#认识-aos"}},[t._v("#")]),t._v(" 认识 AOS")]),t._v(" "),a("p",[t._v("抽象类 AQS 同样继承自抽象类 AOS（AbstractOwnableSynchronizer）")]),t._v(" "),a("p",[t._v("AOS 内部只有一个 Thread 类型的变量，提供了获取和设置当前独占锁线程的方法")]),t._v(" "),a("p",[t._v("主要作用是 "),a("strong",[t._v("记录当前占用独占锁（互斥锁）的线程实例")])]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("abstract")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AbstractOwnableSynchronizer")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("java"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("io"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")])]),t._v("Serializable")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 独占线程（不参与序列化）")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("transient")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" exclusiveOwnerThread"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置当前独占的线程")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setExclusiveOwnerThread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" thread"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        exclusiveOwnerThread "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" thread"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回当前独占的线程")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getExclusiveOwnerThread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" exclusiveOwnerThread"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br")])]),a("h3",{attrs:{id:"为什么要掌握-aqs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要掌握-aqs"}},[t._v("#")]),t._v(" 为什么要掌握 AQS")]),t._v(" "),a("p",[t._v("如何能够体现程序员的水平，那就是掌握大多数人所不掌握的技术，这也是为什么面试时 AQS 高频出现的原因，因为它不简单")]),t._v(" "),a("p",[t._v("最初接触 ReentrantLock 以及 AQS 的时候，看到源码就是一头雾水，Debug 跟着跟着就 "),a("strong",[t._v("迷失了自己")]),t._v("，相信这也是大多数人的反应")]),t._v(" "),a("p",[t._v("正是因为经历过，所以才能从小白的心理上出发，把其中的知识点能够尽数梳理")]),t._v(" "),a("p",[t._v("作者写的很用心，看过这篇文章的小伙伴，不敢保证百分百理解 AQS 和 ReentrantLock 的原理，但是一定会有所收获")]),t._v(" "),a("h2",{attrs:{id:"独占加锁源码解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#独占加锁源码解析"}},[t._v("#")]),t._v(" 独占加锁源码解析")]),t._v(" "),a("h3",{attrs:{id:"什么是独占锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是独占锁"}},[t._v("#")]),t._v(" 什么是独占锁")]),t._v(" "),a("p",[t._v("独占锁也叫排它锁，是指该锁一次只能被一个线程所持有，如果别的线程想要获取锁，只有等到持有锁线程释放")]),t._v(" "),a("p",[t._v("获得排它锁的线程即能读数据又能修改数据，与之对立的就是共享锁")]),t._v(" "),a("p",[t._v("共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁")]),t._v(" "),a("p",[t._v("获得共享锁的线程只能读数据，不能修改数据")]),t._v(" "),a("h3",{attrs:{id:"独占锁加锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#独占锁加锁"}},[t._v("#")]),t._v(" 独占锁加锁")]),t._v(" "),a("p",[t._v("ReentrantLock 就是独占锁的一种实现方式，接下来看代码中如何使用 ReentrantLock 完成独占式加锁业务逻辑")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建非公平锁")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReentrantLock")]),t._v(" lock "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReentrantLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取锁操作")]),t._v("\n    lock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("lock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 执行代码逻辑")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Exception")]),t._v(" ex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("finally")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 解锁操作")]),t._v("\n        lock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("unlock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br")])]),a("p",[t._v("new ReentrantLock() 构造函数默认创建的是非公平锁 NonfairSync")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReentrantLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    sync "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NonfairSync")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReentrantLock")]),t._v(" lock "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReentrantLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReentrantLock")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true 代表公平锁，false 代表非公平锁")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReentrantLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" fair"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    sync "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" fair "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FairSync")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NonfairSync")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义")]),t._v(" "),a("p",[a("strong",[t._v("公平锁 FairSync")])]),t._v(" "),a("ol",[a("li",[t._v("公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁")]),t._v(" "),a("li",[t._v("公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大")])]),t._v(" "),a("p",[a("strong",[t._v("非公平锁 NonfairSync")])]),t._v(" "),a("ol",[a("li",[t._v("非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁")]),t._v(" "),a("li",[t._v("非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁")])]),t._v(" "),a("p",[t._v("两者的都继承自 ReentrantLock 静态抽象内部类 Sync，"),a("strong",[t._v("Sync 类继承自 AQS")]),t._v("，这里就有个疑问")]),t._v(" "),a("p",[t._v("这些锁都没有直接继承 AQS，而是定义了一个 "),a("strong",[t._v("Sync 类去继承 AQS")]),t._v("，为什么要这样呢？")]),t._v(" "),a("p",[t._v("因为 "),a("strong",[t._v("锁面向的是使用用户")]),t._v("，"),a("strong",[t._v("同步器面向的则是线程控制")]),t._v("，那么在锁的实现中聚合同步器而不是直接继承 AQS 就可以很好的 "),a("strong",[t._v("隔离二者所关注的事情")])]),t._v(" "),a("p",[t._v("通过对不同锁种类的讲解以及 ReentrantLock 内部结构的解析，根据上下级关系继承图，加深其理解")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201106104059148.png",alt:""}})]),t._v(" "),a("p",[t._v("这里以非公平锁举例，查看加锁的具体过程，详细信息下文会详细说明")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201117222132211.png",alt:""}})]),t._v(" "),a("p",[t._v("看一下非公平锁加锁方法 lock 内部怎么做的")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReentrantLock")]),t._v(" lock "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReentrantLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nlock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("lock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReentrantLock")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("lock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    sync"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("lock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Sync")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("abstract")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("lock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("p",[a("strong",[t._v("Sync#lock")]),t._v(" 为抽象方法，最终会调用其子类非公平锁的方法 lock")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("lock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSetState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setExclusiveOwnerThread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("currentThread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("非公平加锁方法有两个逻辑")]),t._v(" "),a("ol",[a("li",[t._v("通过比较并替换 State（同步状态）成功与否决定是否获得锁，设置 State 为 1表示成功获取锁，并将当前线程设置为独占线程")]),t._v(" "),a("li",[t._v("修改 State 值失败则进入尝试获取锁流程，acquire 方法为 AQS 提供的方法")])]),t._v(" "),a("p",[t._v("compareAndSetState 以 CAS 比较并替换的方式将 State 值设置为 1，表示同步状态被占用")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSetState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" expect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" update"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// See below for intrinsics setup to support this")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" unsafe"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSwapInt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StateOffset")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" expect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" update"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("setExclusiveOwnerThread 设置当前线程为独占锁拥有线程")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setExclusiveOwnerThread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" thread"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    exclusiveOwnerThread "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" thread"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("acquire 对整个 AQS 做到了承上启下的作用，通过 tryAcquire 模版方法进行尝试获取锁，获取锁失败包装当前线程为 Node 节点加入等待队列排队")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v("            "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquireQueued")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addWaiter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("EXCLUSIVE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("selfInterrupt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("tryAcquire 是 AQS 中抽象模版方法，但是内部会有默认实现，虽然默认的方法内部抛出异常，"),a("strong",[t._v("为什么不直接定义为抽象方法呢?")])]),t._v(" "),a("p",[t._v("因为 AQS 不只是对独占锁实现了抽象，同时还包括共享锁；不同锁定义了不同类别的方法，共享锁就不需要 tryAcquire，如果定义为抽象方法，继承 AQS 子类都需要实现该方法")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UnsupportedOperationException")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("NonfairSync 类中有 tryAcquire 重写方法，继续查看具体如何进行非公平方式获取锁")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" acquires"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("nonfairTryAcquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("acquires"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("nonfairTryAcquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" acquires"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),t._v(" current "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("currentThread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" c "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// State 等于0表示此时无锁    if (c == 0) {      \t// 再次使用CAS尝试获取锁, 表现为非公平锁特性        if (compareAndSetState(0, acquires)) {          \t// 设置线程为独占锁线程            setExclusiveOwnerThread(current);            return true;        }    // 如果当前线程等于已获取锁线程, 表现为可重入锁特性    } else if (current == getExclusiveOwnerThread()) {        int nextc = c + acquires;        if (nextc < 0) // overflow            throw new Error("Maximum lock count exceeded");      \t// 设置 State        setState(nextc);        return true;    }  \t// 如果state不等于0并且独占线程不是当前线程, 返回 false    return false;}')]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("由于 tryAcquire 做了取反，如果设置 state 失败并且独占锁线程不是自己本身返回 false，通过取反会进入接下来的流程")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v("            "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquireQueued")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addWaiter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("EXCLUSIVE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("selfInterrupt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h3",{attrs:{id:"node-入队流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-入队流程"}},[t._v("#")]),t._v(" Node 入队流程")]),t._v(" "),a("p",[t._v("尝试获得锁失败，接下来会将线程组装成为 Node 进行入队流程")]),t._v(" "),a("p",[t._v("Node 是 AQS 中最基本的数据结构，也是 CLH 变体队列中的节点，Node 有 "),a("strong",[t._v("SHARED（共享）、EXCLUSIVE（独占）")]),t._v(" 两种模式，文章主要介绍 EXCLUSIVE 模式，不相关的属性和方法不予介绍")]),t._v(" "),a("p",[t._v("下面列出关于 Node EXCLUSIVE 模式的一些关键方法以及状态信息")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("关键方法与属性")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("对应含义")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("waitStatus")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("当前节点在队列中处于什么状态")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("thread")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("表示节点对应的线程")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("prev")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("前驱指针，指向本节点的上一个节点")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("next")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("后继指针，指向本节点的下一个节点")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("predecessor")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("返回前驱节点，没有的话抛出 NPE 异常")])])])]),t._v(" "),a("p",[t._v("Node 中独占锁相关的 waitStatus 属性分别有以下几种状态")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("属性值")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("值含义")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("0")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("Node 被初始化后的默认值")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("CANCELLED")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("值为1，由于中断或超时，节点被取消")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("SIGNAL")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("值为-1，表示节点的后继节点即将被阻塞")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("CONDITION")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("值为-2，表示节点在等待队列中，节点线程等待唤醒")])])])]),t._v(" "),a("p",[t._v("介绍完 Node 相关基础知识，看一下请求锁线程如何被包装为 Node，又是如何初始化入队的")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addWaiter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" mode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("currentThread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" mode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取等待队列的尾节点    Node pred = tail;  \t// 如果尾节点不为空, 将 node 设置为尾节点, 并将原尾节点 next 指向 新的尾节点node    if (pred != null) {        node.prev = pred;        if (compareAndSetTail(pred, node)) {            pred.next = node;            return node;        }    }  \t// 尾部为空，enq 执行    enq(node);    return node;}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("pred 为队列的尾节点，根据尾节点是否为空会执行对应流程")]),t._v(" "),a("ol",[a("li",[t._v("尾节点不为空，证明队列已被初始化，那么需要将对应的 node（当前线程）设置为新的尾节点，也就是入队操作；将 node 节点的前驱指针指向 pred（尾节点），并将 node 通过 CAS 方式设置为 AQS 等待队列的尾节点，替换成功后将原来的尾节点后继指针指向新的尾节点")]),t._v(" "),a("li",[t._v("尾节点为空，证明还没有初始化队列，执行 enq 方法进行初始化队列")])]),t._v(" "),a("p",[t._v("enq 方法执行初始化队列操作，等待队列中虚拟化的头节点也是在这里产生")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("enq")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" t "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" tail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("          \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 虚拟化一个空Node, 并将head指向空Node            if (compareAndSetHead(new Node()))              \t// 将尾节点等于头节点                tail = head;        } else {          \t// node上一条指向尾节点            node.prev = t;          \t// 设置node为尾节点            if (compareAndSetTail(t, node)) {              \t// 设置原尾节点的下一条指向node                t.next = node;                return t;            }        }    }}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[a("strong",[t._v("执行 enq 方法的前提就是队列尾节点为空，为什么还要再判断尾节点是否为空？")])]),t._v(" "),a("p",[t._v("因为 enq 方法中是一个死循环，循环过程中 t 的值是不固定的。假如执行 enq 方法时队列为空，for 循环会执行两遍不同的处理逻辑")]),t._v(" "),a("ol",[a("li",[t._v("尾节点为空，虚拟化出一个新的 Node 头节点，这时队列中只有一个元素，为了保证 AQS 队列结构的完整性，会将尾节点指向头节点，第一遍循环结束")]),t._v(" "),a("li",[t._v("第二遍不满足尾节点为空条件，执行 else 语句块，node 节点前驱指针指向尾节点，并将 node 通过 CAS 设置为新的尾节点，成功后设置原尾节点的后继指针指向 node，至此入队成功。返回的 t 无意义，只是为了终止死循环")])]),t._v(" "),a("p",[t._v("画两张图来理解 enq 方法整体初始化 AQS 队列流程，假设T1、T2两个线程争取锁，T1成功获得锁，T2进行入队操作")]),t._v(" "),a("ol",[a("li",[t._v("T2进行入队操作，循环第一遍，尾节点为空。开始初始化头节点，并将尾节点指向头节点，最终队列形式是这样纸滴")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114213221013.png",alt:""}})]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("循环第二遍，需要将 node 设置为新的尾节点。逻辑如下：尾节点不为空，设置 node 前驱指针指向尾节点，并将 node 设置为尾节点，原尾节点 next 指针指向 node")])]),t._v(" "),a("p",[t._v("addWaiter 方法就是为了让 Node 入队，并且维护出一个双向队列模型")]),t._v(" "),a("p",[t._v("入队执行成功后，会在 acquireQueued 再次尝试竞争锁，竞争失败后会将线程阻塞")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v("            "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquireQueued")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addWaiter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("EXCLUSIVE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("selfInterrupt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("acquireQueued 方法会尝试自旋获取锁，获取失败对当前线程实施阻塞流程，这也是为了避免无意义的自旋，对比 CLH 队列性能优化的体现")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquireQueued")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" failed "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" interrupted "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("          \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取node上一个节点            final Node p = node.predecessor();          \t// 如果node为头节点 & 尝试获取锁成功            if (p == head && tryAcquire(arg)) {              \t// 此时当前node线程获取到了锁              \t// 将node设置为新的头节点                setHead(node);              \t// help GC                p.next = null;                failed = false;                return interrupted;            }            if (shouldParkAfterFailedAcquire(p, node) &&                    parkAndCheckInterrupt())                interrupted = true;        }    } finally {        if (failed)            cancelAcquire(node);    }}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("通过 node.predecessor() 获取节点的前驱节点，前驱节点为空抛出空指针异常")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("predecessor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throws")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NullPointerException")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" prev"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NullPointerException")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("获取到前驱节点后进行两步逻辑判断")]),t._v(" "),a("ol",[a("li",[t._v("判断前驱节点 p 是否为头节点，为 true 进行尝试获取锁，获取锁成功设置当前节点为新的头节点，并将原头节点的后驱指针设为空")]),t._v(" "),a("li",[t._v("前驱节点不是头节点或者尝试加锁失败，执行线程休眠阻塞操作")])]),t._v(" "),a("p",[t._v("如果 node 获得锁后，setHead 将节点设置为队列头，从而实现出队效果，出于 GC 的考虑，清空未使用的数据")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setHead")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    head "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("thread "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prev "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("shouldParkAfterFailedAcquire 需要重点关注下，流程相对比较难理解")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shouldParkAfterFailedAcquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" pred"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" ws "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pred"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("waitStatus"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ws "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("SIGNAL"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ws "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("            node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prev "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pred "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pred"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prev"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pred"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("waitStatus "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("        pred"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSetWaitStatus")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pred"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ws"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("SIGNAL"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("ws 表示为当前申请锁节点前驱节点的等待状态，代码中包含三个逻辑，分别是：")]),t._v(" "),a("ol",[a("li",[t._v("ws == Node.SIGNAL，表示需要将申请锁节点进行阻塞")]),t._v(" "),a("li",[t._v("ws > 0，表示等待队列中包含被取消节点，需要调整队列")]),t._v(" "),a("li",[t._v("如果 ws == Node.SIGNAL || ws >0 都为 false，使用 CAS 的方式将前驱节点等待状态设置为 Node.SIGNAL")])]),t._v(" "),a("blockquote",[a("p",[t._v("设置当前节点的前置节点等待状态为 Node.SIGNAL，表示当前节点获取锁失败，需要进行阻塞操作")])]),t._v(" "),a("p",[t._v("还是通过几张图来理解流程，假设此时 T1、T2 线程来争夺锁")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114213609335.png",alt:""}})]),t._v(" "),a("p",[t._v("T1 线程获得锁，T2 进入 AQS 等待队列排队，并通过 CAS 将 T2 节点的前驱节点等待状态置为 SIGNAL")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201109140133492.png",alt:""}})]),t._v(" "),a("p",[t._v("执行切换前驱节点等待状态后返回 false，继续进行循环尝试获取同步状态")]),t._v(" "),a("blockquote",[a("p",[t._v("这一步操作保证了线程能进行多次重试，尽量避免线程状态切换")])]),t._v(" "),a("p",[t._v("如果 T1 线程没有释放锁，T2 线程第二次执行到 shouldParkAfterFailedAcquire 方法，因为前驱节点已设置为 SIGNAL，所以会直接返回 true，执行线程阻塞操作")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("parkAndCheckInterrupt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将当前线程进行阻塞    LockSupport.park(this);  \t// 方法返回了当前线程的中断状态，并将当前线程的中断标识设置为false    return Thread.interrupted();}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("LockSupport.park 方法将当前等待队列中线程进行阻塞操作，线程执行一个从 RUNNABLE 到 WAITING 状态转变")]),t._v(" "),a("p",[t._v("如果线程被唤醒，通过执行 Thread.interrupted 查看中断状态，这里的中断状态会被传递到 acquire 方法")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v("            "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquireQueued")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addWaiter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("EXCLUSIVE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("      \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果线程被中断, 这里会再次设置中断状态      \t// 因为如果线程中断, 调用 Thread.interrupted 虽然会返回 true, 但是会清除线程中断状态        selfInterrupt();}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("即使线程从 park 方法中唤醒后发现自己被中断了，但是不影响接下来的获取锁操作，如果需要设置线程中断来影响流程，可以使用 lockInterruptibly 获得锁，抛出检查异常 InterruptedException")]),t._v(" "),a("h3",{attrs:{id:"cancelacquire"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cancelacquire"}},[t._v("#")]),t._v(" cancelAcquire")]),t._v(" "),a("p",[t._v("取消排队方法是 AQS 中比较难的知识点，不容易被理解")]),t._v(" "),a("p",[t._v("当线程因为自旋或者异常等情况获取锁失败，会调用此方法进行取消正在获取锁的操作")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("cancelAcquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 不存在的节点直接返回    if (node == null)        return;    node.thread = null;    /**     * waitStatus > 0 代表节点为取消状态     * while循环会将node节点的前驱指针指向一个非取消状态的节点     * pred等于当前节点的前驱节点（非取消状态）     */    Node pred = node.prev;    while (pred.waitStatus > 0)        node.prev = pred = pred.prev;    // 获取过滤后的前驱节点的后继节点    Node predNext = pred.next;    // 设置node等待状态为取消状态    node.waitStatus = Node.CANCELLED;    // 🚩步骤一，如果node是尾节点，使用CAS将pred设置为新的尾节点  \t    if (node == tail && compareAndSetTail(node, pred)) {      \t// 设置pred（新tail）的后驱指针为空        compareAndSetNext(pred, predNext, null);    } else {        int ws;      \t// 🚩步骤二，node的前驱节点pred（非取消状态）!= 头节点        if (pred != head             \t/**            \t * 1. pred等待状态等于SIGNAL            \t * 2. ws <= 0并且设置pred等待状态为SIGNAL            \t */            \t&& ((ws = pred.waitStatus) == Node.SIGNAL || (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL)))             \t// pred中线程不为空            \t&& pred.thread != null) {            Node next = node.next;          \t/**          \t * 1. 当前节点的后继节点不为空          \t * 2. 后继节点等待状态<=0（表示非取消状态）          \t */            if (next != null && next.waitStatus <= 0)              \t// 设置pred的后继节点设置为当前节点的后继节点                compareAndSetNext(pred, predNext, next);        } else {          \t// 🚩步骤三，如果当前节点为头节点或者上述条件不满足, 执行唤醒当前节点的后继节点流程            unparkSuccessor(node);        }        node.next = node; // help GC    }}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("逻辑稍微复杂一些，比较重要是以下三个逻辑")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("步骤一当前节点为尾节点的话，设置 pred 节点为新的尾节点，成功设置后再将 pred 后继节点设置为空（尾节点不会有后继节点）")])]),t._v(" "),a("li",[a("p",[t._v("步骤二需要满足以下四个条件才会将前驱节点（非取消状态）的后继指针指向当前节点的后继指针")]),t._v(" "),a("p",[t._v("1）当前节点不等于尾节点")]),t._v(" "),a("p",[t._v("2）当前节点前驱节点不等于头节点")]),t._v(" "),a("p",[t._v("3）前驱节点的等待状态不为取消状态")]),t._v(" "),a("p",[t._v("4）前驱节点的拥有线程不为空")])]),t._v(" "),a("li",[a("p",[t._v("如果不满足步骤二的话，会执行步骤三相关逻辑，唤醒后继节点")])])]),t._v(" "),a("p",[a("strong",[t._v("步骤一：")])]),t._v(" "),a("p",[t._v("假设当前取消节点为尾节点并且前置节点无取消节点，现有等待队列如下图，执行下述逻辑")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" tail "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSetTail")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" pred"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSetNext")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pred"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" predNext"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[a("img",{attrs:{src:"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201112180208027.png",alt:""}})]),t._v(" "),a("p",[t._v("将 pred 设置为新的尾节点，并将 pred 后继节点设置为空，因为尾节点不会有后继节点了")]),t._v(" "),a("p",[t._v("T4 线程所在节点因无引用指向，会被 GC 垃圾回收处理")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114141417895.png",alt:""}})]),t._v(" "),a("p",[a("strong",[t._v("步骤二：")])]),t._v(" "),a("p",[t._v("如果当前需要取消节点的前驱节点为取消状态节点，如图所示")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114140258406.png",alt:""}})]),t._v(" "),a("p",[t._v("设置 pred（非取消状态）的后继节点为 node 的后继节点，并设置 node 的 next 为 自己本身")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114141329010.png",alt:""}})]),t._v(" "),a("p",[a("strong",[t._v("线程T2、T3所在节点因为被T4所直接或间接指向，如何进行GC?")])]),t._v(" "),a("p",[t._v("AQS 等待队列中取消状态节点会在 shouldParkAfterFailedAcquire 方法中被 GC 垃圾回收")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ws "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("        node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prev "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pred "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pred"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prev"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pred"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("waitStatus "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    pred"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("T4 线程所在节点获取锁失败尝试停止时，会执行上述代码，执行后的等待队列如下图所示")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://images-machen.oss-cn-beijing.aliyuncs.com/image-20201114144243192.png",alt:""}})]),t._v(" "),a("p",[t._v("等待队列中取消状态节点就可以被 GC 垃圾回收了，至此加锁流程也就结束了，下面继续看如何解锁")]),t._v(" "),a("h2",{attrs:{id:"独占解锁源码解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#独占解锁源码解析"}},[t._v("#")]),t._v(" 独占解锁源码解析")]),t._v(" "),a("p",[t._v("解锁流程相对于加锁简单了很多，调用对应API-lock.unlock()")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReentrantLockpublic")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("unlock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    sync"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("release")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AQSpublic")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("release")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 尝试释放锁    if (tryRelease(arg)) {        Node h = head;        if (h != null && h.waitStatus != 0)            unparkSuccessor(h);        return true;    }    return false;}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h3",{attrs:{id:"释放锁同步状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#释放锁同步状态"}},[t._v("#")]),t._v(" 释放锁同步状态")]),t._v(" "),a("p",[t._v("tryRelease 是定义在 AQS 中的抽象方法，通过 Sync 类重写了其实现")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("protected")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryRelease")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" releases"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" c "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" releases"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果当前线程不等于拥有锁线程, 抛出异常    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    boolean free = false;    if (c == 0) {        free = true;      \t// 将拥有锁线程设置为空        setExclusiveOwnerThread(null);    }  \t// 设置State状态为0, 解锁成功    setState(c);    return free;}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h3",{attrs:{id:"唤醒后继节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#唤醒后继节点"}},[t._v("#")]),t._v(" 唤醒后继节点")]),t._v(" "),a("p",[t._v("此时 State 值已被释放，对于头节点的判断这块流程比较有意思")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" h "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" head"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" h"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("waitStatus "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\t\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("unparkSuccessor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[a("strong",[t._v("什么情况下头节点为空")]),t._v("，当线程还在争夺锁，队列还未初始化，头节点必然是为空的")]),t._v(" "),a("p",[t._v("当头节点等待状态等于0，证明后继节点还在自旋，不需要进行后继节点唤醒")]),t._v(" "),a("p",[t._v("如果同时满足上述两个条件，会对等待队列头节点的后继节点进行唤醒操作")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("unparkSuccessor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取node等待状态    int ws = node.waitStatus;    if (ws < 0)        compareAndSetWaitStatus(node, ws, 0);  \t// 获取node的后继节点    Node s = node.next;  \t// 如果下个节点为空或者被取消, 遍历队列查询非取消节点    if (s == null || s.waitStatus > 0) {        s = null;      \t// 从队尾开始查找, 等待状态 <= 0 的节点        for (Node t = tail; t != null && t != node; t = t.prev)            if (t.waitStatus <= 0)                s = t;    }  \t// 满足 s != null && s.waitStatus <= 0  \t// 执行 unpark    if (s != null)        LockSupport.unpark(s.thread);}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[a("strong",[t._v("为什么查找队列中未被取消的节点需要从尾部开始？")])]),t._v(" "),a("p",[t._v("这个问题有两个原因可以解释，分别是 Node 入队和清理取消状态的节点")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("先从 addWaiter 入队时说起，compareAndSetTail(pred, node)、pred.next = node 并非原子操作，如果在执行 pred.next = node 前进行 unparkSuccessor，就没有办法通过 next 指针向后遍历，所以才会从后向前找寻非取消的节点")])]),t._v(" "),a("li",[a("p",[t._v("cancelAcquire 方法也有导致使用 head 无法遍历全部 Node 的因素，因为先断开的是 next 指针，prev 指针并未断开")])])]),t._v(" "),a("h3",{attrs:{id:"唤醒阻塞后流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#唤醒阻塞后流程"}},[t._v("#")]),t._v(" 唤醒阻塞后流程")]),t._v(" "),a("p",[t._v("当线程获取锁失败被 park 后进入了阻塞模式，前驱节点释放锁后会进行唤醒 unpark，被阻塞线程状态回归 RUNNABLE 状态")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("parkAndCheckInterrupt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 从此位置唤醒    LockSupport.park(this);    return Thread.interrupted();}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("被唤醒线程检查自身是否被中断，返回自身中断状态到 acquireQueued")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquireQueued")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" failed "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" interrupted "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),t._v(" p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("predecessor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" head "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("                "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setHead")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("                p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// help GC                failed = false;                return interrupted;            }            if (shouldParkAfterFailedAcquire(p, node) &&                    parkAndCheckInterrupt())                interrupted = true;        }    } finally {        if (failed)            cancelAcquire(node);    }}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("假设自身被中断，设置 interrupted = true，继续通过循环尝试获取锁，获取锁成功后返回 interrupted 中断状态")]),t._v(" "),a("p",[a("strong",[t._v("中断状态本身并不会对加锁流程产生影响")]),t._v("，被唤醒后还是会不断进行获取锁，直到获取锁成功进行返回，返回中断状态是为了后续补充中断纪录")]),t._v(" "),a("p",[t._v("如果线程被唤醒后发现中断，成功获取锁后会将中断状态返回，补充中断状态")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryAcquire")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v("            "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("acquireQueued")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addWaiter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("EXCLUSIVE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" arg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("selfInterrupt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("selfInterrupt 就是对线程中断状态的一个补充，补充状态成功后，流程结束")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("selfInterrupt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("currentThread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("interrupt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h2",{attrs:{id:"阅读源码小技巧"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阅读源码小技巧"}},[t._v("#")]),t._v(" 阅读源码小技巧")]),t._v(" "),a("p",[a("strong",[t._v("1、从全局掌握要阅读的源码提供了什么功能")])]),t._v(" "),a("p",[t._v("这也是我一直推崇的学习源码方式，学习源码的关键点是抓住主线流程，在了解主线之前不要最开始就研究到源码实现细节中，否则很容易迷失在细枝末节的代码中")]),t._v(" "),a("p",[t._v("以文章中的 AQS 举例，当你知道了它是一个抽象队列同步器，使用它可以更简单的构造锁和同步器等实现")]),t._v(" "),a("p",[t._v("然后从中理解 tryAcquire、tryRelease 等方法实现，这样是不是可以更好的理解与 AQS 与其子类相关的代码")]),t._v(" "),a("p",[a("strong",[t._v("2、把不易理解的源码粘贴出来，整理好格式打好备注")])]),t._v(" "),a("p",[t._v("一般源码中的行为格式和我们日常敲代码是不一样的，而且 JDK 源码中的变量命名实在是惨不忍睹")]),t._v(" "),a("p",[t._v("所以就应该将难以理解的源码粘贴出，标上对应注释以及调整成易理解的格式，这样对于源码的阅读就会轻松很多")]),t._v(" "),a("h2",{attrs:{id:"后记"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#后记"}},[t._v("#")]),t._v(" 后记")]),t._v(" "),a("p",[t._v("平常工作中接触到 AQS 相关知识还是很多的，知其然知其所以然，文章以 ReentrantLock 作为切入点，讲述了其公平锁和非公平锁的概念，以及对应 AQS 中 CLH、AOS 等不容易被发现的概念")]),t._v(" "),a("p",[t._v("针对 ReentrantLock 以及 AQS 加锁、解锁、排队等流程进行了详细说明，以图文并茂的方式讲述了其流程源码实现细节，这里希望在看的小伙伴都能收获 AQS 相关知识")]),t._v(" "),a("p",[a("strong",[t._v("由于作者水平有限, 欢迎大家能够反馈指正文章中错误不正确的地方, 感谢 🙏")])]),t._v(" "),a("p",[t._v("小伙伴的喜欢就是对我最大的支持, 如果读了文章有所收获, 希望能够 "),a("strong",[t._v("点赞、评论、关注三连!")])]),t._v(" "),a("p",[t._v("参考资料")]),t._v(" "),a("ul",[a("li",[t._v("https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html")]),t._v(" "),a("li",[t._v("https://tech.meituan.com/2018/11/15/java-lock.html")]),t._v(" "),a("li",[t._v("https://mp.weixin.qq.com/s/y_e3ciU-hiqlb5vseuOFyw")]),t._v(" "),a("li",[t._v("https://zhuanlan.zhihu.com/p/197840259?utm_source=wechat_session")]),t._v(" "),a("li",[t._v("https://blog.csdn.net/java_lyvee/article/details/98966684")]),t._v(" "),a("li",[t._v("https://zhuanlan.zhihu.com/p/197840259?utm_source=wechat_session")])])])}),[],!1,null,null,null);s.default=e.exports}}]);